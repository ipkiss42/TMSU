use std::ffi::OsString;
use std::fs;
use std::io::{self, Read, Seek, Write};
use std::ops;
use std::path::Path;

use blake2::VarBlake2b;
use digest::generic_array::{ArrayLength, GenericArray};
use digest::{Digest, VariableOutputDirty};
use md5::Md5;
use sha1::Sha1;
use sha2::Sha256;

// These should be imports instead, but rust-analyzer treats tham as errors (maybe because they are
// generated by typenum's script?)
type U32 = digest::consts::U32;
type U256 = digest::consts::U256;
// use digest::consts::{U32, U256};

use crate::entities::{
    DirectoryFingerprintAlgorithm, FileFingerprintAlgorithm, SymlinkFingerprintAlgorithm,
};
use crate::errors::*;

const SPARSE_FINGERPRINT_THRESHOLD: u64 = 5 * 1024 * 1024;
const SPARSE_FINGERPRINT_SIZE: usize = 512 * 1024;

#[allow(unused)] // FIXME: temporary
pub fn create<P: AsRef<Path>>(
    path: P,
    file_fingerprint_algorithm: &FileFingerprintAlgorithm,
    directory_fingerprint_algorithm: &DirectoryFingerprintAlgorithm,
    symlink_fingerprint_algorithm: &SymlinkFingerprintAlgorithm,
) -> Result<String> {
    let path = path.as_ref();

    // Get metadata without following symlinks
    let mut metadata = match fs::symlink_metadata(path) {
        Ok(meta) => meta,
        Err(_) => return Ok("".to_owned()),
    };

    if metadata.file_type().is_symlink() {
        if *symlink_fingerprint_algorithm == SymlinkFingerprintAlgorithm::Follow {
            metadata = match path.metadata() {
                Ok(meta) => meta,
                Err(_) => return Ok("".to_owned()),
            };
        } else {
            return compute_symlink_fingerprint(path, symlink_fingerprint_algorithm);
        }
    }

    if metadata.file_type().is_dir() {
        compute_directory_fingerprint(path, directory_fingerprint_algorithm)
    } else {
        // Regular file (it cannot be a symlink at this point, thanks to the call to Path::metadata())
        compute_file_fingerprint(path, file_fingerprint_algorithm, metadata.len())
    }
}

fn compute_file_fingerprint(
    path: &Path,
    algorithm: &FileFingerprintAlgorithm,
    file_size: u64,
) -> Result<String> {
    match algorithm {
        FileFingerprintAlgorithm::None => Ok("".to_owned()),
        FileFingerprintAlgorithm::DynamicSha1 => dynamic_fingerprint::<Sha1>(path, file_size),
        FileFingerprintAlgorithm::DynamicSha256 => dynamic_fingerprint::<Sha256>(path, file_size),
        FileFingerprintAlgorithm::DynamicMd5 => dynamic_fingerprint::<Md5>(path, file_size),
        FileFingerprintAlgorithm::DynamicBlake2b => {
            dynamic_fingerprint::<Blake2b256>(path, file_size)
        }
        FileFingerprintAlgorithm::RegularSha1 => regular_fingerprint::<Sha1>(path),
        FileFingerprintAlgorithm::RegularSha256 => regular_fingerprint::<Sha256>(path),
        FileFingerprintAlgorithm::RegularMd5 => regular_fingerprint::<Md5>(path),
        FileFingerprintAlgorithm::RegularBlake2b => regular_fingerprint::<Blake2b256>(path),
    }
}

fn compute_directory_fingerprint(
    path: &Path,
    algorithm: &DirectoryFingerprintAlgorithm,
) -> Result<String> {
    match algorithm {
        DirectoryFingerprintAlgorithm::None => Ok("".to_owned()),
        DirectoryFingerprintAlgorithm::RegularSumSizes => sum_sizes_fingerprint(path, 0),
        DirectoryFingerprintAlgorithm::DynamicSumSizes => sum_sizes_fingerprint(path, 500),
    }
}

fn compute_symlink_fingerprint(
    path: &Path,
    algorithm: &SymlinkFingerprintAlgorithm,
) -> Result<String> {
    match algorithm {
        SymlinkFingerprintAlgorithm::None => Ok("".to_owned()),
        SymlinkFingerprintAlgorithm::TargetName => symlink_target_name_fingerprint(path, true),
        SymlinkFingerprintAlgorithm::TargetNameNoExt => {
            symlink_target_name_fingerprint(path, false)
        }
        SymlinkFingerprintAlgorithm::Follow => {
            panic!("Bug: the 'follow' symlink algorithm should already have been handled")
        }
    }
}

fn dynamic_fingerprint<D: Digest + Write>(path: &Path, file_size: u64) -> Result<String>
where
    D::OutputSize: ops::Add,
    <D::OutputSize as ops::Add>::Output: ArrayLength<u8>,
{
    if file_size > SPARSE_FINGERPRINT_THRESHOLD {
        return sparse_fingerprint::<D>(path, file_size);
    }
    regular_fingerprint::<D>(path)
}

fn regular_fingerprint<D: Digest + Write>(path: &Path) -> Result<String>
where
    D::OutputSize: ops::Add,
    <D::OutputSize as ops::Add>::Output: ArrayLength<u8>,
{
    let mut hasher = D::new();
    let mut file = fs::File::open(path)?;
    io::copy(&mut file, &mut hasher)?;
    Ok(format!("{:x}", hasher.finalize()))
}

fn sparse_fingerprint<D: Digest + Write>(path: &Path, file_size: u64) -> Result<String>
where
    D::OutputSize: ops::Add,
    <D::OutputSize as ops::Add>::Output: ArrayLength<u8>,
{
    let mut hasher = D::new();
    let mut file = fs::File::open(path)?;
    let mut buffer = [0; SPARSE_FINGERPRINT_SIZE];

    // Start
    let n = file.read(&mut buffer)?;
    hasher.update(&buffer[..n]);

    // Middle
    // FIXME: unsafe cast?
    file.seek(io::SeekFrom::Start(
        (file_size - SPARSE_FINGERPRINT_SIZE as u64) / 2,
    ))?;
    let n = file.read(&mut buffer)?;
    hasher.update(&buffer[..n]);

    // End
    // FIXME: unsafe cast?
    file.seek(io::SeekFrom::End(-(SPARSE_FINGERPRINT_SIZE as i64)))?;
    let n = file.read(&mut buffer)?;
    hasher.update(&buffer[..n]);

    Ok(format!("{:x}", hasher.finalize()))
}

/// Create a crude directory fingerprint by adding the size of the contained files
fn sum_sizes_fingerprint(path: &Path, max_files: usize) -> Result<String> {
    let mut file_count: usize = 0;
    let mut total_size: u64 = 0;
    // We store options in the Vec to avoid ownership issues:
    // we can take() values from options without holding a borrow on `paths`
    let mut paths = vec![Some(path.to_path_buf())];

    let mut index = 0;
    'out: while index < paths.len() {
        let path = paths[index]
            .take()
            .expect("Bug: a None path should never be encountered");
        let read_dir_res = path.read_dir();
        // Ignore errors
        if let Ok(entries) = read_dir_res {
            // Ignore errors and unwrap while iterating directory entries
            for child in entries.filter_map(|res| res.ok()) {
                let metadata = child.metadata();
                // Ignore errors
                if let Ok(metadata) = metadata {
                    if metadata.is_dir() {
                        let joined_child = path.join(child.path());
                        paths.push(Some(joined_child));
                    } else {
                        total_size += metadata.len();
                        file_count += 1;

                        if max_files != 0 && file_count >= max_files {
                            break 'out;
                        }
                    }
                }
            }
        }

        // Move to the next path
        index += 1;
    }

    Ok(format!("{:x}", total_size))
}

/// Use the symbolic target's filename as the fingerprint
fn symlink_target_name_fingerprint(path: &Path, include_extension: bool) -> Result<String> {
    let target = path.read_link()?;
    if !target.exists() {
        return Ok("".to_owned());
    }

    // TODO: can this be simplified and be made to work for non-UTF8 paths?
    let base_os_string = target
        .file_name()
        .unwrap_or(&OsString::from("."))
        .to_owned();
    let mut base: String = base_os_string.into_string()?;
    if !include_extension {
        // FIXME: this mimics the Go implementation, but this is wrong.
        // See https://github.com/oniony/TMSU/issues/208
        if let Some(p) = base.find('.') {
            base = base.get(..p).unwrap().to_owned();
        }
    }

    Ok(base)
}

/// The default Blake2b has 512 bytes of output, but we want only 256 for backwards compatibility
/// with the Go implementation. The VarBlake2b struct allows that, but it doesn't implement the
/// Digest trait, which means we can't use it in generic code like the other hashes.
///
/// So we create our own wrapper around VarBlake2b, which implements the Digest trait.
/// It should ideally be done upstream, see https://github.com/RustCrypto/hashes/issues/67
/// TODO: it shouldn't be too difficult to generalize this and contribute upstream.
#[derive(Clone)]
struct Blake2b256(VarBlake2b);

type Output = GenericArray<u8, U32>;

impl Default for Blake2b256 {
    fn default() -> Self {
        Self(VarBlake2b::new_keyed(&[], 32))
    }
}

impl digest::BlockInput for Blake2b256 {
    type BlockSize = U256;
}

impl digest::Reset for Blake2b256 {
    fn reset(&mut self) {
        self.0.reset()
    }
}

impl digest::Update for Blake2b256 {
    fn update(&mut self, data: impl AsRef<[u8]>) {
        self.0.update(data);
    }
}

impl digest::FixedOutputDirty for Blake2b256 {
    type OutputSize = U32;

    fn finalize_into_dirty(&mut self, out: &mut Output) {
        self.0.finalize_variable_dirty(|sl| out.copy_from_slice(sl));
    }
}

impl io::Write for Blake2b256 {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        self.0.write(buf)
    }

    fn flush(&mut self) -> io::Result<()> {
        self.0.flush()
    }
}

#[cfg(test)]
mod tests {
    use std::env;
    use std::fs::File;

    use super::*;

    // Shortcuts
    type DFA = DirectoryFingerprintAlgorithm;
    type FFA = FileFingerprintAlgorithm;
    type SFA = SymlinkFingerprintAlgorithm;

    const SMALL_SIZE: u64 = 2 * 1024 * 1024;
    const BIG_SIZE: u64 = 6 * 1024 * 1024;

    // Create a temporary directory and call the callback, making sure to
    // delete the directory if there was no failure
    fn within_temp_directory<P, F>(dir_name: P, callback: F) -> Result<()>
    where
        P: AsRef<Path>,
        F: FnOnce(&Path) -> Result<()>,
    {
        let directory = env::temp_dir().join(dir_name);

        // (Re-)create the directory structure
        if directory.exists() {
            fs::remove_dir_all(&directory)?;
        }
        fs::create_dir_all(&directory)?;

        callback(&directory)?;

        // Clean up on success
        fs::remove_dir_all(&directory)?;
        Ok(())
    }

    // Write a single '!' at the end of the file to make it the right size
    fn write_file_for_size<P: AsRef<Path>>(path: P, file_size: u64) -> Result<()> {
        let mut file = File::create(path.as_ref())?;

        file.seek(io::SeekFrom::Start(file_size - 1))?;
        file.write("!".as_bytes())?;

        Ok(())
    }

    fn assert_file_fingerprint(algorithm: FFA, ext: &str, file_size: u64, expected: &str) {
        within_temp_directory(format!("tmsu-fingerprint-file.{}", ext), |dir| {
            let file_path = dir.join(ext);
            write_file_for_size(&file_path, file_size).unwrap();

            let fingerprint =
                super::create(&file_path, &algorithm, &DFA::None, &SFA::None).unwrap();

            assert_eq!(&fingerprint, expected);
            Ok(())
        })
        .unwrap();
    }

    #[test]
    fn regular_none_fingerprint() {
        assert_file_fingerprint(FFA::None, "reg-none", SMALL_SIZE, "");
        assert_file_fingerprint(FFA::None, "reg-none", BIG_SIZE, "");
    }

    #[test]
    fn regular_md5_fingerprint() {
        let expected = "a758071b3c2fe43c9a9b91db5077cd12";
        assert_file_fingerprint(FFA::RegularMd5, "reg-md5", SMALL_SIZE, expected);
        let expected = "40cb0a2f629169e30c2ef707255b33d5";
        assert_file_fingerprint(FFA::RegularMd5, "reg-md5", BIG_SIZE, expected);
    }

    #[test]
    fn regular_sha1_fingerprint() {
        let expected = "09bc65c6f6588b802177632a81b3afbe3358b7f3";
        assert_file_fingerprint(FFA::RegularSha1, "reg-sha1", SMALL_SIZE, expected);
        let expected = "6dfb0884a5f2738700b9beb5473f3dd9c9fd2762";
        assert_file_fingerprint(FFA::RegularSha1, "reg-sha1", BIG_SIZE, expected);
    }

    #[test]
    fn regular_sha256_fingerprint() {
        let expected = "cdf701ac9e4258a8efec453930c73d698d12d7e83c38a049a1f1a64375fbf776";
        assert_file_fingerprint(FFA::RegularSha256, "reg-sha256", SMALL_SIZE, expected);
        let expected = "a4bd6407e40326c126f10412e245e4491c511636dbeddc3d2b16b41700017bc9";
        assert_file_fingerprint(FFA::RegularSha256, "reg-sha256", BIG_SIZE, expected);
    }

    #[test]
    fn regular_blake2b_fingerprint() {
        let expected = "76b01099c5121e2436f3cb201f3917e4f46eae7dac8ac0c941b1729101e91de4";
        assert_file_fingerprint(FFA::RegularBlake2b, "reg-blake2b", SMALL_SIZE, expected);
        let expected = "fdc4dc9cebbd6f162b3dad4d196646df430dbae8c547df01447285da55247087";
        assert_file_fingerprint(FFA::RegularBlake2b, "reg-blake2b", BIG_SIZE, expected);
    }

    #[test]
    fn dynamic_md5_fingerprint() {
        let expected = "a758071b3c2fe43c9a9b91db5077cd12";
        assert_file_fingerprint(FFA::DynamicMd5, "dyn-md5", SMALL_SIZE, expected);
        let expected = "668a4b622482b9fd30b1ad0eac4ab8f1";
        assert_file_fingerprint(FFA::DynamicMd5, "dyn-md5", BIG_SIZE, expected);
    }

    #[test]
    fn dynamic_sha1_fingerprint() {
        let expected = "09bc65c6f6588b802177632a81b3afbe3358b7f3";
        assert_file_fingerprint(FFA::DynamicSha1, "dyn-sha1", SMALL_SIZE, expected);
        let expected = "30af88de9e731520fbcb4ec5f7276af8e06eb61b";
        assert_file_fingerprint(FFA::DynamicSha1, "dyn-sha1", BIG_SIZE, expected);
    }

    #[test]
    fn dynamic_sha256_fingerprint() {
        let expected = "cdf701ac9e4258a8efec453930c73d698d12d7e83c38a049a1f1a64375fbf776";
        assert_file_fingerprint(FFA::DynamicSha256, "dyn-sha256", SMALL_SIZE, expected);
        let expected = "0a9f9c7cd5939b04ad4bb7d14f801fe671c1b622d0e3b7769798b14dbdbf07f1";
        assert_file_fingerprint(FFA::DynamicSha256, "dyn-sha256", BIG_SIZE, expected);
    }

    #[test]
    fn dynamic_blake2b_fingerprint() {
        let expected = "76b01099c5121e2436f3cb201f3917e4f46eae7dac8ac0c941b1729101e91de4";
        assert_file_fingerprint(FFA::DynamicBlake2b, "dyn-blake2b", SMALL_SIZE, expected);
        let expected = "137c5b1e9e8107c176de7fb7a38f7670bb31364fadb2b5b883737c8732c78327";
        assert_file_fingerprint(FFA::DynamicBlake2b, "dyn-blake2b", BIG_SIZE, expected);
    }

    fn assert_directory_fingerprint(algorithm: DFA, expected: &str) {
        within_temp_directory("tmsu-fingerprint-dir", |dir| {
            let subdir = dir.join("sub");
            fs::create_dir_all(&subdir)?;

            // Create 1000 files in each directory
            for i in 1..=1000 {
                let i_str = i.to_string();
                fs::write(dir.join(&i_str), &i_str)?;
                fs::write(subdir.join(&i_str), format!("hello {} world", i))?;
            }

            let fingerprint = super::create(&dir, &FFA::None, &algorithm, &SFA::None)?;
            assert_eq!(fingerprint, expected);

            Ok(())
        })
        .unwrap();
    }

    #[test]
    fn directory_fingerprint() {
        assert_directory_fingerprint(DFA::RegularSumSizes, "457a");
        assert_directory_fingerprint(DFA::DynamicSumSizes, "5dd");
        assert_directory_fingerprint(DFA::None, "");
    }

    fn assert_symlink_fingerprint(algorithm: SFA, expected1: &str, expected2: &str) {
        within_temp_directory("tmsu-fingerprint-symlink", |dir| {
            // Create links and a target file: link1 -> link2.ext -> target.ext1.ext2
            let path_link1 = dir.join("link1");
            let path_link2 = dir.join("link2.ext");
            let path_target = dir.join("target.ext1.ext2");
            fs::write(&path_target, "This file\ncontains\nthree lines\n")?;
            std::os::unix::fs::symlink(&path_target, &path_link2)?;
            std::os::unix::fs::symlink(&path_link2, &path_link1)?;

            let fingerprint1 =
                super::create(&path_link1, &FFA::RegularMd5, &DFA::None, &algorithm)?;
            assert_eq!(fingerprint1, expected1);
            let fingerprint2 =
                super::create(&path_link2, &FFA::RegularMd5, &DFA::None, &algorithm)?;
            assert_eq!(fingerprint2, expected2);

            Ok(())
        })
        .unwrap();
    }

    #[test]
    fn symlink_fingerprint() {
        let expected = "48dc8df61c7322d9a0fa6731f4ca97b1";
        assert_symlink_fingerprint(SFA::Follow, expected, expected);
        assert_symlink_fingerprint(SFA::TargetName, "link2.ext", "target.ext1.ext2");
        assert_symlink_fingerprint(SFA::TargetNameNoExt, "link2", "target");
        assert_symlink_fingerprint(SFA::None, "", "");
    }

    #[test]
    fn symlink_pointing_to_parent_dir() {
        within_temp_directory("tmsu-fingerprint-sym-to-dir", |dir| {
            let subdir = dir.join("sub");
            fs::create_dir_all(&subdir)?;
            let path_link = subdir.join("link");
            std::os::unix::fs::symlink(&subdir, &path_link)?;

            let fingerprint =
                super::create(&path_link, &FFA::None, &DFA::RegularSumSizes, &SFA::Follow)?;
            assert_eq!(fingerprint, "24");

            Ok(())
        })
        .unwrap();
    }

    #[test]
    fn symlink_cycle() {
        within_temp_directory("tmsu-fingerprint-sym-cycle", |dir| {
            let link1 = dir.join("link1");
            let link2 = dir.join("link2");
            std::os::unix::fs::symlink(&link1, &link2)?;
            std::os::unix::fs::symlink(&link2, &link1)?;

            let fingerprint = super::create(&link1, &FFA::None, &DFA::None, &SFA::Follow)?;
            assert_eq!(fingerprint, "");

            Ok(())
        })
        .unwrap();
    }
}
